<?php

declare(strict_types=1);

namespace Modules\Security\Application\Service;

class MalwareScanner
{
    private array $patterns = [
        'eval_usage' => '/\beval\s*\(/i',
        'base64_decode_usage' => '/\bbase64_decode\s*\(/i',
        'shell_exec_usage' => '/\bshell_exec\s*\(/i',
        'system_usage' => '/\bsystem\s*\(/i',
        'passthru_usage' => '/\bpassthru\s*\(/i',
        'proc_open_usage' => '/\bproc_open\s*\(/i',
        'popen_usage' => '/\bpopen\s*\(/i',
        'pcntl_exec_usage' => '/\bpcntl_exec\s*\(/i',
        'backticks_usage' => '/`.*`/',
        'iframe_injection' => '/<iframe/i',
        'hex_obfuscation' => '/\\\\x[0-9a-fA-F]{2}/'
    ];
    
    // Whitelisted files (files that legitimately use these functions)
    private array $whitelist = [
        'MalwareScanner.php', // Self
        'composer.phar',
        'vendor', // Usually we skip vendor, but maybe user wants deep scan? Default skip.
        'storage/logs',
        'storage/cache',
        '.git'
    ];

    public function scan(string $rootPath): array
    {
        $results = [];
        $files = $this->getFiles($rootPath);
        
        foreach ($files as $file) {
            $content = file_get_contents($file);
            $matches = [];
            
            foreach ($this->patterns as $name => $pattern) {
                if (preg_match_all($pattern, $content, $hits, PREG_OFFSET_CAPTURE)) {
                    foreach ($hits[0] as $hit) {
                        $matches[] = [
                            'pattern' => $name,
                            'snippet' => substr($content, max(0, $hit[1] - 20), 50), // Show context
                            'line' => substr_count(substr($content, 0, $hit[1]), "\n") + 1
                        ];
                    }
                }
            }
            
            if (!empty($matches)) {
                $results[] = [
                    'file' => str_replace($rootPath, '', $file),
                    'threats' => $matches
                ];
            }
        }
        
        return $results;
    }

    private function getFiles(string $dir): \Generator
    {
        if (!is_dir($dir)) return;
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($dir, \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $path = $file->getPathname();
                
                // Check Whitelist
                $skip = false;
                foreach ($this->whitelist as $w) {
                    if (str_contains($path, $w) || str_contains($path, DIRECTORY_SEPARATOR . $w)) {
                        $skip = true; // Use simple string check for now
                        break;
                    }
                }
                
                if (!$skip) {
                    yield $path;
                }
            }
        }
    }
}
